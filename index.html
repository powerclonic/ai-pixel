<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI generic trash coded pixel game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@2.0.6/css/pico.min.css" />
  <style>
    :root { --hud-bg: rgba(0,0,0,0.55); }
    html,body { height:100%; margin:0; background:#111; color:#eee; overflow:hidden; font-family:system-ui, sans-serif; }
    #canvasContainer { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    #board { image-rendering: pixelated; cursor:crosshair; background:#222; box-shadow:0 0 0 1px #333; }
    #fabBar { position:fixed; top:.75rem; left:.75rem; display:flex; gap:.5rem; flex-wrap:wrap; z-index:60; }
    #fabBar button { font-size:.7rem; padding:.45rem .7rem; }
    #hud { position:fixed; bottom:.6rem; left:.6rem; background:var(--hud-bg); backdrop-filter:blur(5px); padding:.55rem .8rem .65rem; border-radius:.6rem; font-size:.7rem; line-height:1.25; z-index:50; width:250px; }
    .bar { height:7px; background:#333; margin-top:4px; position:relative; border-radius:4px; overflow:hidden; }
    .fill { position:absolute; inset:0; width:0%; background:linear-gradient(90deg,#ff9800,#ffa733); transition:width .12s linear; }
    #regenFill { background:linear-gradient(90deg,#2e7d32,#43a047); }
    #boardCoords { position:fixed; top:.6rem; right:.8rem; background:var(--hud-bg); padding:.35rem .7rem; border-radius:.5rem; font-size:.7rem; z-index:50; }
    #palettePanel { position:fixed; bottom:.6rem; left:calc(.6rem + 260px); background:var(--hud-bg); backdrop-filter:blur(5px); padding:.45rem .55rem .55rem; border-radius:.6rem; display:flex; flex-direction:column; gap:.35rem; max-width:50vw; z-index:50; }
    #livePalette { display:flex; flex-wrap:wrap; gap:4px; max-width:420px; }
    #livePalette button { width:24px; height:24px; padding:0; border:1px solid #000; cursor:pointer; position:relative; }
    #livePalette button.selected { outline:2px solid #fff; }
    #livePalette button.extra:not(.owned){ outline:2px dashed #888; }
    #livePalette button.extra.owned { box-shadow:0 0 0 2px rgba(255,215,0,0.35); }
    #rankingList { max-height:320px; overflow:auto; font-size:.85rem; }
    dialog { max-width:520px; }
    .outline { outline:2px dashed #666; }
    .dialog-footer { display:flex; gap:.5rem; flex-wrap:wrap; }
    #cooldownMode { font-size:.65rem; opacity:.8; }
  </style>
</head>
<body>
  <div id="canvasContainer"><canvas id="board" width="256" height="144"></canvas></div>
  <div id="fabBar">
    <button id="btnAuth" class="secondary"></button>
    <button id="openRanking">Ranking</button>
    <button id="openInfo">Info</button>
  </div>
  <div id="boardCoords"></div>
  <div id="hud">
    <div><strong>Players:</strong> <span id="playerCount">0</span> | <strong>Pixels:</strong> <span id="totalPixelsHUD">0</span></div>
    <div><span id="cooldownMode">-</span> <span id="cooldownText"></span></div>
    <div>Stash: <span id="storedPixels">0</span>/<span id="capacity">0</span> | Credits: <span id="credits">0</span> | Ping: <span id="latency">-</span>ms</div>
    <div class="bar"><div id="cooldownFill" class="fill"></div></div>
    <div class="bar"><div id="regenFill" class="fill"></div></div>
  </div>
  <div id="palettePanel">
    <div style="display:flex; align-items:center; gap:.5rem; flex-wrap:wrap;">
      <strong style="font-size:.7rem">Palette</strong>
      <button id="btnUpgrades" class="secondary" style="font-size:.55rem; padding:.3rem .55rem;">Upgrades</button>
    </div>
    <div id="livePalette"></div>
  </div>
  <!-- Dialogs -->
  <dialog id="authDialog"><article><h3>Sign in / Register</h3><form id="authForm"><input name="username" placeholder="Username" minlength="3" maxlength="20" required /><input name="password" placeholder="Password" type="password" minlength="4" required /><footer class="dialog-footer"><button value="register">Register</button><button value="login">Login</button><button type="button" class="secondary" onclick="authDialog.close()">Close</button></footer></form></article></dialog>
  <dialog id="paletteDialog"><article><header><h3>Upgrades / Extra Colors</h3></header><section><p style="font-size:.75rem">Select a color in the floating palette. Use credits to buy extra colors or increase capacity.</p><h6>Extra Colors</h6><div id="extraColors"></div><button id="buyColorBtn" class="secondary" disabled style="margin-top:.5rem">Buy selected color (<span id="colorCost"></span>)</button><hr /><h6>Capacity</h6><p style="font-size:.7rem">Stored pixels capacity: <span id="capacity"></span></p><button id="upgradeCapacityBtn" class="contrast" disabled>Upgrade Capacity (<span id="capacityUpgradeCost"></span>)</button></section><footer class="dialog-footer"><button onclick="paletteDialog.close()" class="secondary">Close</button></footer></article></dialog>
  <dialog id="rankingDialog"><article><header><h3>Ranking</h3></header><ol id="rankingList"></ol><footer class="dialog-footer"><button onclick="rankingDialog.close()" class="secondary">Close</button></footer></article></dialog>
  <dialog id="infoDialog"><article><header><h3>Info</h3></header><p>Simplified collaborative pixel board. Earn 1 credit per placed pixel. Spend credits on extra colors and capacity. Use as many accounts as u want.</p><p>Share coordinates: URL ?x=..&y=..</p><ul style="font-size:.75rem; opacity:.8"><li>[P] Palette dialog</li><li>[R] Ranking</li><li>[I] Info</li><li>[ESC] Close dialogs</li></ul><footer class="dialog-footer"><button onclick="infoDialog.close()" class="secondary">Close</button></footer></article></dialog>
<script>
const $ = s=>document.querySelector(s);
const board=$('#board'); const ctx=board.getContext('2d');
let config, me, ws, selectedColor=null, baseCooldown=5, boardW=256, boardH=144, allowedColors=[], extraColors=[], boughtColors=new Set(), pingStart=0, regenInterval=5, lastPlaceTs=null, cooldownOverrideRemaining=null;
let viewScale=4, minScale=1, maxScale=40, offsetX=0, offsetY=0; let isPanning=false; let panStart={x:0,y:0,ox:0,oy:0,moved:false};
const offscreen=document.createElement('canvas'); const offctx=offscreen.getContext('2d');
let pixelMeta=new Map();
// Background image layer
const mapCanvas=document.createElement('canvas'); const mapCtx=mapCanvas.getContext('2d');
let mapVisible=true, mapOpacity=0.3, mapReady=false; let bgImg=null;
function qs(){ return new URLSearchParams(location.search); }
function updateURLCoords(x,y){ const p=qs(); p.set('x',x); p.set('y',y); history.replaceState(null,'','?'+p.toString()); }
function updateMinScale(){ minScale = Math.min(window.innerWidth/boardW, window.innerHeight/boardH); if(viewScale<minScale){ viewScale=minScale; centerBoard(); }}
function centerBoard(){ const visibleW=window.innerWidth/viewScale, visibleH=window.innerHeight/viewScale; if(visibleW>=boardW) offsetX=(boardW-visibleW)/2; else offsetX=Math.min(Math.max(0,offsetX), boardW-visibleW); if(visibleH>=boardH) offsetY=(boardH-visibleH)/2; else offsetY=Math.min(Math.max(0,offsetY), boardH-visibleH); }
function constrainView(){ centerBoard(); }
function redraw(){ ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,board.width,board.height); const vw=window.innerWidth/viewScale, vh=window.innerHeight/viewScale; if(mapVisible && mapReady){ ctx.save(); ctx.globalAlpha=mapOpacity; ctx.drawImage(mapCanvas, offsetX, offsetY, vw, vh, 0,0, board.width, board.height); ctx.restore(); } ctx.drawImage(offscreen, offsetX, offsetY, vw, vh, 0, 0, board.width, board.height); }
let defaultBoardColor = '#FFFFFF';
function drawBoardSparse(defaultColor, pixels){
  defaultBoardColor = defaultColor;
  offscreen.width=boardW; offscreen.height=boardH;
  offctx.clearRect(0,0,boardW,boardH); // leave transparent so background shows through
  pixelMeta.clear();
  const batchSize=12000; let i=0;
  function drawBatch(){
    const end=Math.min(i+batchSize, pixels.length);
    for(;i<end;i++){
      const [x,y,color,u,ts]=pixels[i];
      if(color!==defaultBoardColor){ // skip drawing default color to keep transparency
        offctx.fillStyle=color; offctx.fillRect(x,y,1,1);
      }
      if(u||ts) pixelMeta.set(x+','+y,{u,t:ts});
    }
    if(i<pixels.length) requestAnimationFrame(drawBatch); else { resizeCanvas(); }
  }
  drawBatch();
}
function setPixel(x,y,color,u,ts){
  if(color===defaultBoardColor){
    offctx.clearRect(x,y,1,1); // restore transparency
    pixelMeta.delete(x+','+y);
  } else {
    offctx.fillStyle=color; offctx.fillRect(x,y,1,1);
    if(u||ts) pixelMeta.set(x+','+y,{u,t:ts});
  }
  redraw();
}
function resizeCanvas(){ board.width=window.innerWidth; board.height=window.innerHeight; updateMinScale(); constrainView(); redraw(); }
window.addEventListener('resize', ()=>{ resizeCanvas(); if(mapReady) redraw(); });
function buildLivePalette(){ const cont=$('#livePalette'); cont.innerHTML=''; const full=allowedColors.concat([...boughtColors]); full.forEach(c=>{ const btn=document.createElement('button'); btn.style.background=c; if(extraColors.includes(c)) { btn.classList.add('extra'); if(boughtColors.has(c)) btn.classList.add('owned'); } btn.onclick=()=>{ selectedColor=c; updatePaletteSelection(); updateBuyColorBtn(); }; if(c===selectedColor) btn.classList.add('selected'); cont.appendChild(btn); }); updatePaletteSelection(); }
function buildExtraColors(){ const ec=$('#extraColors'); ec.innerHTML=''; extraColors.forEach(c=>{ const b=document.createElement('button'); b.style.background=c; b.title=c; if(!boughtColors.has(c)) b.classList.add('outline'); b.onclick=()=>{ selectedColor=c; updatePaletteSelection(); updateBuyColorBtn(); }; ec.appendChild(b); }); }
function updatePaletteSelection(){ [...document.querySelectorAll('#livePalette button')].forEach(b=>{ const col=b.style.background.toUpperCase(); if(selectedColor && col===selectedColor.toUpperCase()) b.classList.add('selected'); else b.classList.remove('selected'); }); }
function updateStatus(){ if(!me) return; $('#storedPixels').textContent=me.storedPixels; $('#capacity').textContent=me.capacity; $('#credits').textContent=me.credits; }
function frameLoop(){ const now=Date.now()/1000; if(me){ const cap=me.capacity||1; const stored=me.storedPixels||0; let regenPct=stored/cap; if(stored<cap && me.lastRegenTs){ const since= now - me.lastRegenTs; const frac=Math.min(1, since/regenInterval); regenPct = (stored + frac)/cap; } $('#regenFill').style.width=(Math.min(1, regenPct)*100)+'%'; let remaining=0; if(me.storedPixels===0){ if(cooldownOverrideRemaining!=null){ remaining=cooldownOverrideRemaining; const estLast= now - (baseCooldown - cooldownOverrideRemaining); lastPlaceTs= lastPlaceTs||estLast; if(remaining<=0) cooldownOverrideRemaining=null; } else if(lastPlaceTs){ remaining = Math.max(0, baseCooldown - (now - lastPlaceTs)); } } if(me.storedPixels>0){ $('#cooldownMode').textContent='Regen'; $('#cooldownText').textContent = (me.storedPixels<me.capacity)? 'next '+ ( Math.max(0, regenInterval - (now - (me.lastRegenTs||now)) ).toFixed(1) +'s') : 'full'; $('#cooldownFill').style.width='100%'; } else { $('#cooldownMode').textContent='Cooldown'; if(remaining>0){ $('#cooldownText').textContent=remaining.toFixed(1)+'s'; $('#cooldownFill').style.width=( (baseCooldown-remaining)/baseCooldown *100)+'%'; } else { $('#cooldownText').textContent='ready'; $('#cooldownFill').style.width='100%'; } } } requestAnimationFrame(frameLoop); }
async function fetchJSON(u){ const r=await fetch(u); if(!r.ok) throw new Error(await r.text()); return r.json(); }
async function postJSON(u,b){ const r=await fetch(u,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b||{})}); if(!r.ok) throw new Error(await r.text()); return r.json(); }
async function loadConfig(){ config=await fetchJSON('/api/config'); $('#colorCost').textContent=config.colorCost; $('#capacityUpgradeCost').textContent=config.capacityUpgradeCost; boardW=config.width; boardH=config.height; allowedColors=config.basePalette.slice(); extraColors=config.extraColors.slice(); baseCooldown=config.baseCooldown; if(config.regenInterval) regenInterval=config.regenInterval; buildLivePalette(); buildExtraColors(); }
async function loadMe(){ try{ me=await fetchJSON('/api/me'); boughtColors=new Set(me.boughtColors); updateStatus(); buildExtraColors(); enableUI(); }catch{ me=null; disableUI(); } }
function enableUI(){ $('#btnAuth').textContent= me? me.username+' (logout)':'Login'; $('#upgradeCapacityBtn').disabled=!me; }
function disableUI(){ $('#btnAuth').textContent='Login'; }
async function initBoard(){ const snap=await fetchJSON('/api/board'); boardW=snap.width; boardH=snap.height; drawBoardSparse(snap.defaultColor, snap.pixels); generateBackground(); }
function generateBackground(){ mapCanvas.width=boardW; mapCanvas.height=boardH; mapReady=false; if(!bgImg){ bgImg=new Image(); bgImg.src='/static/image.png'; bgImg.onload=()=>{ drawBg(); }; bgImg.onerror=()=>{ console.warn('Background image failed to load'); }; } else { drawBg(); } }
function drawBg(){ if(!bgImg||!bgImg.complete) return; mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height); const iw=bgImg.naturalWidth, ih=bgImg.naturalHeight; if(!iw||!ih) return; const scale=Math.max(boardW/iw, boardH/ih); const dw=iw*scale, dh=ih*scale; const dx=(boardW-dw)/2; const dy=(boardH-dh)/2; mapCtx.drawImage(bgImg, dx, dy, dw, dh); mapReady=true; redraw(); }
function connectWS(){ if(!me) return; ws=new WebSocket((location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws'); ws.onopen=()=>{ pingStart=performance.now(); ws.send(JSON.stringify({type:'ping'})); }; ws.onmessage=e=>{ const m=JSON.parse(e.data); if(m.type==='init'){ if(m.user){ me=m.user; boughtColors=new Set(me.boughtColors); lastPlaceTs=me.lastPlaceTs; updateStatus(); buildLivePalette(); buildExtraColors(); enableUI(); } if(boardW!==m.width||boardH!==m.height){ boardW=m.width; boardH=m.height; generateBackground(); } drawBoardSparse(m.defaultColor, m.pixels||[]); $('#totalPixelsHUD').textContent=m.totalPixels; updateRanking(m.ranking); const p=qs(); const x=p.get('x'), y=p.get('y'); if(x&&y) highlightCoord(+x,+y); } else if(m.type==='pixel'){ setPixel(m.x,m.y,m.color,m.username,m.placedAt); $('#totalPixelsHUD').textContent=m.totalPixels; ws.send(JSON.stringify({type:'ping'})); } else if(m.type==='player_count'){ $('#playerCount').textContent=m.count; } else if(m.type==='ranking'){ updateRanking(m.ranking); } else if(m.type==='cooldown'){ cooldownOverrideRemaining=m.remaining; } else if(m.type==='me'){ if(m.user){ me=m.user; boughtColors=new Set(me.boughtColors); lastPlaceTs=me.lastPlaceTs; updateStatus(); buildLivePalette(); buildExtraColors(); }} else if(m.type==='pong'){ $('#latency').textContent=Math.round(performance.now()-pingStart); setTimeout(()=>{ pingStart=performance.now(); ws.send(JSON.stringify({type:'ping'})); },5000); } }; ws.onclose=()=>setTimeout(connectWS,3000); }
function updateRanking(list){ const el=$('#rankingList'); el.innerHTML=''; list.forEach(r=>{ const li=document.createElement('li'); li.textContent=r.username+': '+r.pixels_placed; el.appendChild(li); }); }
const hoverBox=document.createElement('div'); hoverBox.style.position='fixed'; hoverBox.style.pointerEvents='none'; hoverBox.style.background='rgba(0,0,0,0.75)'; hoverBox.style.padding='4px 6px'; hoverBox.style.borderRadius='4px'; hoverBox.style.fontSize='10px'; hoverBox.style.color='#fff'; hoverBox.style.fontFamily='system-ui,sans-serif'; hoverBox.style.zIndex='70'; hoverBox.style.display='none'; document.body.appendChild(hoverBox);
function fmtTime(ts){ if(!ts) return ''; const d=new Date(ts*1000); return d.toISOString().replace('T',' ').substring(11,19); }
board.addEventListener('mousemove', e=>{ const rect=board.getBoundingClientRect(); const relX=e.clientX-rect.left, relY=e.clientY-rect.top; const x=Math.floor(offsetX + relX/viewScale); const y=Math.floor(offsetY + relY/viewScale); $('#boardCoords').textContent=`(${x},${y}) ${selectedColor||''}`; const meta=pixelMeta.get(x+','+y); if(meta){ hoverBox.innerHTML=`<strong>${meta.u||'?'}</strong><br>${fmtTime(meta.t)}`; hoverBox.style.left=(e.clientX+12)+'px'; hoverBox.style.top=(e.clientY+12)+'px'; hoverBox.style.display='block'; } else { hoverBox.style.display='none'; } });
board.addEventListener('mouseleave',()=>{ hoverBox.style.display='none'; });
board.addEventListener('mousedown', e=>{ if(e.button===0){ isPanning=true; panStart={x:e.clientX,y:e.clientY,ox:offsetX,oy:offsetY,moved:false}; } else if(e.button===1||e.button===2){ isPanning=true; panStart={x:e.clientX,y:e.clientY,ox:offsetX,oy:offsetY,moved:false}; e.preventDefault(); }});
window.addEventListener('mousemove', e=>{ if(isPanning){ const dx=(e.clientX-panStart.x)/viewScale; const dy=(e.clientY-panStart.y)/viewScale; if(Math.abs(dx)>0.5||Math.abs(dy)>0.5) panStart.moved=true; offsetX=panStart.ox - dx; offsetY=panStart.oy - dy; constrainView(); redraw(); }});
window.addEventListener('mouseup', ()=>{ isPanning=false; });
function canPlace(){ if(!me||!selectedColor) return false; if(me.storedPixels>0) return true; const now=Date.now()/1000; if(lastPlaceTs==null) return true; return (now - lastPlaceTs) >= baseCooldown; }
board.addEventListener('click', e=>{ if(isPanning && panStart.moved) return; if(!canPlace()) return; const rect=board.getBoundingClientRect(); const relX=e.clientX-rect.left, relY=e.clientY-rect.top; const x=Math.floor(offsetX + relX/viewScale); const y=Math.floor(offsetY + relY/viewScale); updateURLCoords(x,y); ws?.send(JSON.stringify({type:'place',x,y,color:selectedColor})); });
board.addEventListener('wheel', e=>{ e.preventDefault(); const direction=Math.sign(e.deltaY); const old=viewScale; if(direction>0) viewScale=Math.max(minScale, viewScale/1.15); else viewScale=Math.min(maxScale, viewScale*1.15); const rect=board.getBoundingClientRect(); const cx=(e.clientX-rect.left)/old + offsetX; const cy=(e.clientY-rect.top)/old + offsetY; offsetX = cx - (e.clientX-rect.left)/viewScale; offsetY = cy - (e.clientY-rect.top)/viewScale; constrainView(); redraw(); }, {passive:false});
window.addEventListener('contextmenu', e=>{ if(e.target===board) e.preventDefault(); });
// Touch controls
let touchPanning=false, pinchZooming=false, pinchStartDist=0, pinchStartScale=1, pinchCenter={x:0,y:0}; let singleTouchStart={x:0,y:0,time:0};
function touchPoint(e,i){ const t=e.touches[i]; const r=board.getBoundingClientRect(); return {x:t.clientX-r.left, y:t.clientY-r.top, clientX:t.clientX, clientY:t.clientY}; }
function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
board.addEventListener('touchstart', e=>{ if(e.touches.length===1){ const p=touchPoint(e,0); touchPanning=true; pinchZooming=false; singleTouchStart={x:p.clientX,y:p.clientY,time:performance.now()}; panStart={x:p.clientX,y:p.clientY,ox:offsetX,oy:offsetY,moved:false}; } else if(e.touches.length===2){ pinchZooming=true; touchPanning=false; const p0=touchPoint(e,0), p1=touchPoint(e,1); pinchStartDist=distance(p0,p1); pinchStartScale=viewScale; pinchCenter={x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2}; } }, {passive:true});
board.addEventListener('touchmove', e=>{ if(pinchZooming && e.touches.length===2){ e.preventDefault(); const p0=touchPoint(e,0), p1=touchPoint(e,1); const dist=distance(p0,p1); if(pinchStartDist>0){ const factor=dist/pinchStartDist; let newScale=pinchStartScale*factor; newScale=Math.min(maxScale, Math.max(minScale,newScale)); const canvasPointX=pinchCenter.x/viewScale + offsetX; const canvasPointY=pinchCenter.y/viewScale + offsetY; viewScale=newScale; offsetX = canvasPointX - pinchCenter.x/viewScale; offsetY = canvasPointY - pinchCenter.y/viewScale; constrainView(); redraw(); } } else if(touchPanning && e.touches.length===1){ e.preventDefault(); const p=touchPoint(e,0); const dx=(p.clientX-panStart.x)/viewScale; const dy=(p.clientY-panStart.y)/viewScale; if(Math.abs(dx)>0.3||Math.abs(dy)>0.3) panStart.moved=true; offsetX=panStart.ox - dx; offsetY=panStart.oy - dy; constrainView(); redraw(); } }, {passive:false});
board.addEventListener('touchend', e=>{ if(pinchZooming && e.touches.length===0) pinchZooming=false; if(touchPanning && e.touches.length===0){ const dt=performance.now()-singleTouchStart.time; if(!panStart.moved && dt<300){ const rect=board.getBoundingClientRect(); const relX=singleTouchStart.x-rect.left, relY=singleTouchStart.y-rect.top; const x=Math.floor(offsetX + relX/viewScale); const y=Math.floor(offsetY + relY/viewScale); if(canPlace()) { updateURLCoords(x,y); ws?.send(JSON.stringify({type:'place',x,y,color:selectedColor})); } } touchPanning=false; } }, {passive:true});
board.addEventListener('touchcancel', ()=>{ touchPanning=false; pinchZooming=false; }, {passive:true});
function highlightCoord(x,y){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=0.5; ctx.strokeRect(x+0.05,y+0.05,0.9,0.9); ctx.restore(); }
$('#btnAuth').addEventListener('click',async e=>{ e.preventDefault(); if(me){ await fetch('/api/logout',{method:'POST'}); me=null; disableUI(); location.reload(); return; } authDialog.showModal(); });
$('#authForm').addEventListener('submit',async e=>{ e.preventDefault(); const fd=new FormData(e.target); const body={username:fd.get('username'),password:fd.get('password')}; const action=e.submitter.value; try{ await postJSON('/api/'+action, body); authDialog.close(); await loadMe(); connectWS(); }catch(err){ alert('Error: '+err); } });
$('#buyColorBtn').addEventListener('click',async ()=>{ if(!selectedColor) return; try{ await postJSON('/api/buy_color',{color:selectedColor}); await loadMe(); boughtColors=new Set(me.boughtColors); allowedColors=config.basePalette.concat([...boughtColors]); buildLivePalette(); buildExtraColors(); updateBuyColorBtn(); }catch(e){ alert('Error: '+e); } });
$('#upgradeCapacityBtn').addEventListener('click',async ()=>{ try{ await postJSON('/api/upgrade_capacity',{}); await loadMe(); }catch(e){ alert('Error: '+e); } });
function updateBuyColorBtn(){ const btn=$('#buyColorBtn'); btn.disabled=!selectedColor || !extraColors.includes(selectedColor) || boughtColors.has(selectedColor) || !me; }
$('#btnUpgrades').onclick=()=>paletteDialog.showModal();
$('#openRanking').onclick=()=>rankingDialog.showModal();
$('#openInfo').onclick=()=>infoDialog.showModal();
// Background controls (visibility + opacity)
const mapCtl=document.createElement('div'); mapCtl.style.position='fixed'; mapCtl.style.right='.75rem'; mapCtl.style.bottom='4.6rem'; mapCtl.style.zIndex='55'; mapCtl.style.background='rgba(0,0,0,0.55)'; mapCtl.style.backdropFilter='blur(5px)'; mapCtl.style.padding='.55rem .7rem .65rem'; mapCtl.style.borderRadius='.6rem'; mapCtl.style.fontSize='.6rem'; mapCtl.innerHTML=`<label style="display:flex;align-items:center;gap:.4rem;">BG <input type="checkbox" id="mapToggle" checked></label><label style="display:flex;align-items:center;gap:.4rem;margin-top:.35rem;">Opacity <input type="range" id="mapOp" min="0" max="1" step="0.05" value="${mapOpacity}"></label>`; document.body.appendChild(mapCtl);
mapCtl.querySelector('#mapToggle').addEventListener('change',e=>{ mapVisible=e.target.checked; redraw(); });
mapCtl.querySelector('#mapOp').addEventListener('input',e=>{ mapOpacity=parseFloat(e.target.value); redraw(); });
function hotkeysEnabled(){ const ae=document.activeElement; const typing=ae && (ae.tagName==='INPUT'||ae.tagName==='TEXTAREA'||ae.isContentEditable); return !typing && !authDialog.open; }
window.addEventListener('keydown', e=>{ if(!hotkeysEnabled()) return; if(e.key==='p'||e.key==='P'){ paletteDialog.open?paletteDialog.close():paletteDialog.showModal(); } else if(e.key==='r'||e.key==='R'){ rankingDialog.open?rankingDialog.close():rankingDialog.showModal(); } else if(e.key==='i'||e.key==='I'){ infoDialog.open?infoDialog.close():infoDialog.showModal(); } else if(e.key==='Escape'){ [paletteDialog,rankingDialog,infoDialog,authDialog].forEach(d=>d.open&&d.close()); } });
async function init(){ await loadConfig(); await loadMe(); await initBoard(); resizeCanvas(); connectWS(); frameLoop(); if(!me) authDialog.showModal(); }
init();
</script>
</body>
</html>
